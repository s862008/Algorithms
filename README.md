# Алгоритмы и структуры данных
<i>Learning data structures and algorithms</i>

Данный материал посвящён самостоятельной реализации ключевых алгоритмов и структур данных на языке Go. Цель — не только отработать практические навыки программирования, но и глубоко понять внутреннюю механику алгоритмов, что критически важно как для профессиональной работы, так и для успешного прохождения технических собеседований.

<p><b>Важные оговорки</b></p>
<ul>
<p><b>Уровень кода:</b> намеренно упрощён для максимальной наглядности. Акцент сделан на ясность логики, а не на оптимизацию или «красивый» код.</p>
<p><b>Язык реализации:</b> Go (Golang). Выбор обусловлен его простотой, строгой типизацией и популярностью в современной разработке.</p>
<p><b>Фокус:</b> понимание принципов, а не готовых библиотек. Мы реализуем всё «с нуля», чтобы увидеть, как работают базовые механизмы.</p>
</ul>
<p><b>Содержание</b></p>
<ul><p><b>Алгоритмы сортировки</b></p>
<li>Пузырьковая сортировка (O(n^2)) — простейший пример, иллюстрирующий идею попарного сравнения.</li>
<li>Сортировка вставками (O(n^2)) — эффективна для малых массивов или почти отсортированных данных.</li>
<li>Сортировка слиянием (O(nlogn)) — пример «разделяй и властвуй», стабильная и предсказуемая по времени.</li>
<ul><i>Дополнение:</i>
<li>Быстрая сортировка (O(nlogn) в среднем) — популярный алгоритм с рекурсивным разбиением.</li>
<li>Пирамидальная сортировка (O(nlogn)) — использует структуру данных «двоичная куча».</li>
</ul>
</ul>
<ul><p><b>Поиск и обход графов</b></p>
<li>Поиск в ширину (BFS) — находит кратчайший путь в невзвешенном графе.</li>
<li>Поиск в глубину (DFS) — исследует все ветви до конца, полезен для топологической сортировки.</li>
<ul><i>Дополнение:</i>
<li>Алгоритм Дейкстры (O((V+E)logV)) — поиск кратчайшего пути в взвешенном графе с неотрицательными рёбрами.</li>
<li>Алгоритм A* — эвристический поиск с оценкой стоимости пути (применяется в играх и навигации).</li>
</ul>
</ul>
<ul><p><b>Математические алгоритмы</b></p>
<li>Числа Фибоначчи — реализация через рекурсию, итерацию и мемоизацию.</li>
<li>Вычисление факториала — пример рекурсивного и итеративного подходов.</li>
<li>Конечный автомат (FSM) — моделирование состояний и переходов (например, для парсинга строк).</li>
<ul><i>Дополнение:</i>
<li>Быстрое возведение в степень (O(logn)) — метод «возведения в квадрат».</li>
<li>Алгоритм Евклида — нахождение НОД двух чисел.</li>
<li>Решето Эратосфена — поиск простых чисел до заданного предела.</li>
</ul>
</ul>
<ul><p><b>Структуры данных</b></p>

<li>Стек (LIFO) — реализация на массиве или связном списке.</li>

<li>Очередь (FIFO) — циклическая очередь и двусвязная реализация.</li>

<li>Связные списки — односвязные и двусвязные, операции вставки/удаления.</li>

<li>Деревья — бинарные деревья поиска, обходы (in-order, pre-order, post-order).</li>

<li>Хэш-таблица — коллизии, методы разрешения (цепочки, открытая адресация).</li>

<ul><i>Дополнение:</i>

<li>Очередь с приоритетом — на основе кучи.</li>

<li>AVL-дерево — самобалансирующееся двоичное дерево.</li>

<li>Префиксное дерево (Trie) — для хранения и поиска строк.</li>
</ul>
</ul>
<ul><p><b>Хэш-функции и основы криптографии</b></p>
<li>Простые хэш-функции — полиномиальный хэш, CRC.</li>
<li>Криптографические хэш-функции — SHA-256 (обзор принципа работы).</li>
<li>Применение в структурах данных — хэш-таблицы, деревья Меркла.</li>
<ul><i>Дополнение:</i>
<li>HMAC — код аутентификации сообщений.</i>
<li>Основы симметричного шифрования — AES (концептуально).</i>
</ul>
</ul>
<ul><p><b>Дополнительные алгоритмы</b></p>

Динамическое программирование — задачи «о рюкзаке», «о количестве путей».

Жадные алгоритмы — задача о размене монет, интервальное планирование.

Поиск подстроки — алгоритм Кнута-Морриса-Пратта (KMP).

Работа с большими числами — длинная арифметика (сложение, умножение).
</ul>
